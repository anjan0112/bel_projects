#include <etherbone.h>
#include <tlu.h>
#include <eca.h>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <unistd.h>

using namespace GSI_ECA;
using namespace GSI_TLU;

#define EXPLODER5_IOS 16

#define EVENTS 2000

typedef struct
{
  uint64_t uTotalEvents;
  uint64_t uMaxDiff;
  uint64_t uMinDiff;
  uint64_t uAverage;
  uint64_t uStdDeviation;
  uint64_t a_uTimestamp[EVENTS];
} s_IOMeasurement;

int main (int argc, const char** argv)
{

  /* Helpers */
  Socket socket;
  Device device;
  status_t status;
  std::vector<TLU> tlus;
  std::vector<std::vector<uint64_t> > queues;

  s_IOMeasurement a_sIOMeasurement[EXPLODER5_IOS];
  int test = 0;


  uint32_t a_uEdges[EVENTS];
  uint64_t a_uFrequency[EVENTS];
  
  Table table;
  uint32_t uQueueInterator = 0;
  uint32_t uQueueItemIterator = 0;
  uint32_t uQueuesTotal = 0;
  uint32_t uQueneItems = 0;
  uint64_t uTimeDiff = 0;
  uint32_t uShiftPosition = 0;
  uint32_t uArrayIterator = 0;
  uint32_t uTestCase = 0;
  uint32_t uIOConfig = 0;
  uint32_t * p_uEdgesExpected = NULL;
  uint32_t * p_uFrequencyExpected = NULL;
  double dExpectedFrequency = 0.0;
  double dMeasuredFrequency = 0.0;


  for(test = 0; test < 16; test++)
  {
    a_sIOMeasurement[test].uTotalEvents = 0;
  }

  for(test = 0; test < 16; test++)
  {
    fprintf(stdout, "%s: ID:%d EVENTS:%ld...\n", argv[0], test, a_sIOMeasurement[test].uTotalEvents);
  }


  /* Try to open a (etherbone-) socket */
  socket.open();
  if ((status = device.open(socket, argv[1])) != EB_OK) 
  {
    fprintf(stderr, "%s: failed to open %s: (status %s)\n", argv[0], argv[1], eb_status(status));
    return 1;
  }
  else
  {
    fprintf(stdout, "%s: succeeded to open %s (status %s)\n", argv[0], argv[1], eb_status(status));
  }
  
  /* Find the TLU */
  TLU::probe(device, tlus);
  assert (tlus.size() == 1);
  TLU& tlu = tlus[0];
  /* Configure the TLU to record rising edge timestamps */
  tlu.hook(-1, false);
  tlu.set_enable(false); // no interrupts, please
  tlu.clear(-1);
  tlu.listen(-1, true, true, 8); /* Listen on all inputs */
  
  /* Find the IO reconfig to enable/disable outputs to specific IOs */
  std::vector<sdb_device> devs;
  device.sdb_find_by_identity(0x651, 0x4d78adfdU, devs);
  assert (devs.size() == 1);
  address_t ioconf = devs[0].sdb_component.addr_first  + 4; // Lemos
  device.write(ioconf, EB_DATA32, 0x00);
  

    
  /* Check TLU */
  while (test!=100)
  {
  
    usleep(50000); 
    test++;

  /* Read-out result */
  tlu.pop_all(queues);
  uQueuesTotal = queues.size();
  //fprintf(stdout, "%s: found queues %d ...\n", argv[0], uQueuesTotal);
  
  
    /* Check each queue now */
  for(uQueueInterator=0; uQueueInterator<uQueuesTotal; uQueueInterator++)
  {
    std::vector<uint64_t>& queue = queues[uQueueInterator];
    uQueneItems = queue.size(); /* Get the actual size */
    if(uQueneItems!=0)
    {
      fprintf(stdout, "%s: queue %d has a size of %d ...\n", argv[0], uQueueInterator, uQueneItems);
    }
    /* Inspect items with queue contains data */
    if(uQueneItems)
    {
      
      for(uQueueItemIterator=0; uQueueItemIterator<uQueneItems; uQueueItemIterator++)
      {
      
       a_sIOMeasurement[uQueueItemIterator].uTotalEvents++;
        //a_uEdges[uQueueInterator]++; /* Count up seen edges */
        fprintf(stdout, "%s: queue[%d][%d]: 0x%"PRIx64" (0x%"PRIx64")... \n", argv[0], uQueueInterator, uQueueItemIterator, queue[uQueueItemIterator]/8, queue[uQueueItemIterator]);
        if(uQueueItemIterator>=1)
        {
        
          //uTimeDiff = queue[uQueueItemIterator]-queue[uQueueItemIterator-1]; 
          //fprintf(stdout, "(difference to previous time stamp 0x%"PRIx64" (%"PRIu64"))\n", uTimeDiff, uTimeDiff);
          //a_uFrequency[uQueueInterator] += uTimeDiff; /* Sum up time stamps */
          /* Allow little jitter/uncertainty */
          //if( ((*p_uFrequencyExpected+TOLERANCE_FACTOR_NS)<uTimeDiff) ||
          //    ((*p_uFrequencyExpected-TOLERANCE_FACTOR_NS)>uTimeDiff)
          //)
          //{
          //  fprintf(stdout, "%s: too much jitter for IO %d!\n", argv[0], uQueueInterator);
          //  return 1;
          //}
        }
        else
        {
          //fprintf(stdout, "\n");
        }
      }
    }
    p_uFrequencyExpected++;
  }
  
  
  
  
  }
  
  

  
  
  
  
  fprintf(stdout, "%s: done!\n", argv[0]);
  
  return 0;
  
}
